<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springboot入门]]></title>
    <url>%2F2018%2F08%2F02%2Fspringboot%2F</url>
    <content type="text"><![CDATA[最近几天，学习Spring Boot相关知识，下面就快速搭建Spring Boot项目。搭建项目工具：Eclipse、maven 创建maven project如下图：项目创建完成。 项目配置pom文件添加spring boot的起步依赖 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 程序启动类在工程主目录下创建程序启动类——HelloApplication，代码如下： package com.luis; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class HelloApplication { public static void main(String[] args) { SpringApplication.run(HelloApplication.class, args); } } 其中@SpringBootApplication注解包含@SpringBootConfiguration、@EnableAuto-Configuration、@ComponentScan，用于开启包扫描、配置、自动配置的功能。Controller文件为演示效果，此web工程，因而需要创建controller,代码如下： package com.luis.web; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @RequestMapping(&quot;/hello&quot;) public String index() { return &quot;Hello World&quot;; } } 其中的@RestController用于表明类为Controller.工程结构图如图所示： 项目测试运行程序启动类HelloApplication，如下图则启动成功！启动成功后，在浏览器访问：localhost:8080/hello,浏览器出现“Hello World”,如下图所示：]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装mysql出现no compatible servers were found]]></title>
    <url>%2F2018%2F08%2F02%2Fmysql%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[问题描述今天在安装数据库的过程中，遇到错误提示： No compatible servers were found，You&apos;ll need to cancel this wizard and install one！ 如下图所示：精通于数据库的安装与卸载的我，竟然也有“湿鞋”的一天，懵逼一段时间之后，首先想到的就是以前的注册表信息没有删干净，嗯，一定是这样，果断去控制面板卸载mysql,找删除mysql注册表的相关博客，经过一段时间的忙碌之后，信誓旦旦的再次开始重装，然后，我被打脸了！！！痛定思痛，努力排查，诶，这mysql server没装成功啊！如图所示：然后想到是不是需要装其他的软件，然后在再次卸载数据库之后我选择了装下面这一大坨东西，以前都是直接选择跳过的，满怀希望，默默等待……然而，他又又失败了，同样的错误。最后根据软件缺失这个思路在网上找到了解决。 解决办法安装失败的原因是需要升级一个插件，Visual C++ 2013 and Visual C Redistributable Package且必须是32位的Visual C++ Redistributable Packages for Visual Studio 2013！！！注意是32位的，与电脑的系统类型无关，即32位，64位系统都要装32位的visual c++我选择从微软官网下载，下载网址： https://www.microsoft.com/zh-cn/download/details.aspx?id=40784进入网址，点击下载，如下图：选择vcredist_x86.exe—6.2 MB，下载并安装安装完成后，再次安装mysql数据库完成，问题解决！！！ 问题解决方出自：https://blog.csdn.net/q95548854/article/details/78780916]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ安装教程]]></title>
    <url>%2F2018%2F08%2F01%2FRibbitMq%2F</url>
    <content type="text"><![CDATA[最近几天在学习Spring Cloud，在学习Spring Cloud Config配置刷新使用Spring Cloud Bus时，其中用到消息代理组件RabbitMQ,在安装RabbitMQ的过程查了很多资料，因此在这里将安装过程记录下来。 安装Erlang由于RabbitMQ服务端代码是使用并发式语言erlang编写的，所以首先要安装erlang环境。Erlang下载 下载地址是：http://www.erlang.org/downloads我的测试环境是windows所以下载的是OTP 20.2 Windows 64-bit Binary FileErlang安装 下载完成后进行安装，可以按照习惯更改安装目录，在此过程中可能遇到安装Visual c++ 的情况不用管，一直点同意，等待安装完成。如下图所示：Erlang配置环境变量 Erlang环境变量配置如下图所示：环境变量配置完毕，可以打开cmd进行测试，输入命令：erl若出现如下图的结果，则环境变量配置成功 安装RabbitMQRabbitMQ下载地址：http://www.rabbitmq.com/download.html下载完成后安装，可选择安装位置，如图所示 安装RabbitMQ-PluginsRabbitMQ-Plugins是一个管理界面，方便我们在浏览器界面查看RabbitMQ各个消息队列以及exchange的工作情况。打开命令行cd进入rabbitmq的sbin目录(我的目录是：D:\Program Files\RabbitMQ Server\rabbitmq_server-3.6.12\sbin)，输入： rabbitmq-plugins enable rabbitmq_management 稍等会会发现出现plugins安装成功的提示，默认是安装6个插件在安装过程中也会出现错误，如下图所示：解决方法是：首先在命令行输入：rabbitmq-service stop接着输入rabbitmq-service remove再输入rabbitmq-service install再输入rabbitmq-service start重新输入rabbitmq-plugins enable rabbitmq_management等待安装成功，当然，我在试验过程中发现不重新安装，直接rabbitmq-service start后也是可以的。 安装验证在浏览器输入http://localhost:15672进行验证,看到下面界面：输入用户名：guest，密码：guest，进入管理界面至此，安装完成！ 本文另参考：https://blog.csdn.net/hzw19920329/article/details/53156015]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集概述]]></title>
    <url>%2F2018%2F07%2F27%2FGCoverview%2F</url>
    <content type="text"><![CDATA[前言很多人将垃圾收集(Garbage Collection)视为Java的伴生产物，实际1960年诞生的Lisp是第一门真正使用内存动态分配与垃圾手机技术的语言。在目前看来，内存的动态分配与内存回收已经相当成熟，但了解GC与内存分配还是非常有必要的，当排查内存溢出、内存泄漏问题，当垃圾手机称为系统高并发的瓶颈时，就需要我们对其实施必要的监控与调节。在前面的篇章中我们了解到Java的运行时区域中的程序计数器、虚拟机栈、本地方法栈的内存分配与回收具有确定性，但Java堆不同，这部分内存的分配与回收都是动态的，婴儿垃圾收集器关注的就是这部分内存。 对象的生与死堆中几乎存放着Java中的所有的对象实例，但在对堆进行回收前，首先要确定对象的“生死”，下面就这方面进行讲解：引用记数算法很多书籍中判断对象存活方法的判断：给对象中添加引用计数器，每当一个地方引用它，计数器值加1；当引用失效，计数器值减1；任何时刻都为0的对象时不能再使用的。引用计数算法应用于python,FlashPlayer及Squirrel中，但Java却没有选用引用计数器算法管理内存，最主要的原因是它很难解决对象之间相互循环引用的问题。根搜索算法主流的商用程序语言(Java、C#、Lisp)都使用根搜索算法(GC Roots Tracing)判定对象是否存活，又称为可达性分析算法。算法的基本思路是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象GC Roots没有任何引用链相连(用图论的表示从GC Roots都这个对象不可达)时，则证明此对象不可用。如下图所示，object4,object5,object6相互关联，但到GC Roots不可达，因而可判定为可回收对象。Java中，可作为GC Roots的对象一般包括下面几种： 虚拟机栈(栈帧中的本地变量表)中的引用的对象 方法区中的类静态属性的引用对象 方法区中的常量引用的对象 本地方法栈中的JNI(Native方法)的引用对象。 引用的理解无论时引用计数算法还是根搜索算法，判断对象存活都与引用相关。JDK1.2之前对Java的引用定义：如果reference类型的数据中存储的数值代表另一块内存的起始地址，称这块内存代表一个引用。这种定义过于狭隘，一个对象这种定义下只有引用或没被引用两种状态，这再很多应用场景下是无法描述的。JDK1.2之后，Java对应用概念进行了扩充，将引用分为强引用(Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、需引用(Phantom Reference)四种，且强度依此减弱。 强引用强引用是指程序代码之中普遍存在的，类似“Object obj = new Object()”的引用，只要强引用存在，垃圾收集器永远不会回收掉被引用的对象。 软引用软引用用来描述一些非必需的有用对象。在系统将要发生内存溢出异常之前，会把软引用关联的对象列进回收范围之中并进行第二次回收。若此次回收没有足够的内存，才会抛出内存溢出异常。 弱应用弱引用描述非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生前，当垃圾回收时，无论内存是否足够，都会回收掉只被若引用关联的对象。 虚引用虚引用也称为幽灵引用或幻影引用，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。对对象设置虚引用关联的唯一目的是希望在这个对象被收集器收集回收时收到一个系统通知。JDK1.2之后，提供了PhantomReference类来实现虚引用。 生存死亡的判断在根搜索算法中不可达的对象，并非是“必死”的，暂时处于“缓刑”阶段一个对象正式死亡，要经理至少两次标记过程。首先如果在进行根搜索后没有发现与GC Roots相连的引用链，它将会被第一次标记并进行一次筛选，筛选的条件是该对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或finalize()方法已被虚拟机调用过，则虚拟机认定该对象为“没有必要执行”。若该对象被判定为有必要执行finalize()方法，那对象将被放置在一个名为F-Quenue队列中，并在稍后由一条虚拟机自动建立的，低优先级的Finalizer线程执行。这里的“执行”是指虚拟机会触发finalize()方法，但并不承诺会等待方法运行结束。这是因为若在执行过程中出现某对象的finalize()方法执行缓慢或发生死循环，队列中的其他对象将会永久处于等待状态，甚至导致内存回收系统崩溃。finalize()方法是对象逃脱死亡的最后一次机会，稍后GC将对F-quene的对象进行第二次小规模标记，若要逃脱死亡命运，只需重新与引用链上的任意对象关联即可，如此，在第二次标记时它将被移出即将回收集合。还没有逃脱的对象只能静静等待死亡的到来。回收方法区很多人认为方法区(HotSpot中的永久代)是没有垃圾收集的，Java虚拟机规范中不要求在方法区实现垃圾收集，且在方法区进行垃圾收集的性能低。永久代的垃圾收集处理的主要是：废弃常量和无用的类。回收常量与Java堆中对象相似。常量池中的回收是判断是否由其他对象引用常量池中的常量，若没有，若此时发生内存回收，此常量将被清出常量池。而对于无用的类的判断条件则相对苛刻，需满足三个条件： 此类所有实例已被回收，即堆中不存在此类的任何实例 加载该类的ClassLoader已被回收 此类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可堆满足条件的无用类进行回收，但具体是否回收，需虚拟机提供的参数-Xnoclassgc进行控制，hai可查看类的加载与卸载信息，在大量使用反射、动态代理等场景及频繁定义ClassLoader的场景需要具备类卸载功能，保证永久代不会溢出。 垃圾收集算法下面就几种算法的思想及发展过程进行介绍。标记 — 清除算法标记清除算法(Mark-Sweep)算法是最基础的收集算法，它分为“标记”和“清除”两部分：首先标记出所有需回收的对象，在标记完成后统一回收掉所有被标记的对象，他的标记过程就是对象的标记判定的过程。后续的收集算法都是基于这种思路并堆其缺点进行改进得到的。它的缺点有两个：效率，标记与清除的过程效率都不高；空间，标记清除后产生大量的不连续内存碎片，空间碎片过多可能导致程序运行分配较大对象时无法找到足够的连续内存提前出发另一次垃圾收集。下图为标记清除算法示意图：复制算法为解决效率问题，出现复制收集算法(Copying)，它将可用内存按容量划分为大小相等的两块，每次使用其中一块，当一块用完，将活着的对象复制到另一块上，将已使用过的内存空间一此清理掉。使得每次都是堆其中一块进行内存回收，就可以忽略了内存碎片的复杂情况，只需移动堆顶指针，按顺序分配内存。算法的代价是将内存缩小为原来的一半，算法执行过程如图所示。当前商业虚拟机采用此算法回收新生代，由于新生代的对象98%是朝生夕死，因而秩序将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和一块Survior。回收时，将Eden和Survivor存活的对象一次拷贝到另一块Survivor空间上，最后清理掉Eden和刚才使用过的Survivor空间。Eden和Survivor大小比例为8：1，每次新生代可用内存空间为90%，但98%回收只是一般情况，若Survivor空间不够用，需要依赖其他内存(老年代)进行分配担保，即通过分配担保机制进入老年代。标记 — 整理算法复制收集算法在对象存活率较高时就执行较多的复制操作，效率将会变低，更关键的是，需要额外的空间进行分配担保，以应对所有对象都存活的极端情况，所以老年代一般不直接选用此算法。针对老年机的特点，又提出了”标记整理(Mark-Compact)“算法，标记过程与”标记-清除算法一致“，后续步骤是直接堆可回收的对象进行清理，让所有存活对象向一端移动，直接清理掉端界面以外的内存，标记-整理算法示意图如图所示：分代收集算法目前的商用虚拟机垃圾收集采用的是“分代收集(Generational Collection)”算法，它根据对象的存活周期的不同将内存划分为几块，一般把Java堆分为新生代和老年代，可根据各个年代的特点采用最合适的收集算法。在新生代中，对象死亡多，存活少，采用复制算法，付出少量复制成本完成收集。老年代存活率高、没有额外空间进行分配担保，使用”标记-整理“或”标记-清理“孙法进行回收。 本文主要参考自《深入理解Java虚拟机——JVM高级特性与最佳实践》一书另部分图片参考文章：https://blog.csdn.net/u011116672/article/details/50994105]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>垃圾收集</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解jvm之Java内存区域]]></title>
    <url>%2F2018%2F07%2F25%2Fjvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Java虚拟机运行时数据区分为以下几个部分：方法区、虚拟机栈、本地方法栈、堆、程序计数器。如下图所示： 程序计数器程序计数器可看作当前线程所执行的字节码行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。Java虚拟机的多线程是通过线程轮流切换以分配处理执行时间的方式进行的，因而为了确保线程切换后能够恢复到正确的执行位置，每条线程都有一个独立的程序计数器，各个线程计数器独立存储，互不影响，这类内存区域称为“线程私有”内存。当线程执行Java方法时，计数器记录的时正在执行虚拟机字节码指令的地址；如果执行Native方法，则计数器值为空(Undefine)。程序计数器时唯一一个在Java虚拟机规范中没有任何规定OutOfMemoryError情况的内存区域。 Java虚拟机栈Java虚拟机栈也是线程私有的，生命周期与线程相同。Java虚拟机栈是描述Java方法执行的内存模型：每个方法执行时都会创建一个栈帧(方法运行期间的基础数据结构)，方法的执行过程对应着相应的栈帧在虚拟机中从入栈到出栈的过程。我们平时提到的栈就是虚拟机栈，也称为局部变量表部分。局部变量表存放了编译期间的各种基本数据类型、对象引用和returAdress类型。其中，double和long占两个局部变量空间(Slot)，其余数据类型占据一个。局部变量表所需内存是在编译期间完成分配的，当进入一个方法时，方法在帧中分配的局部变量空间大小是完全确定的，在方法运行期间局部变量表的大小不变。Java虚拟机栈规定了两种异常状况： 线程请求栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常。 虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时抛出OutOfMemoryError异常。 本地方法栈本地方法栈为虚拟机使用的Native方法服务，本地方法栈可根据虚拟机的具体要求自由实现。由的虚拟机(如Sun HotSpot虚拟机)直接将本地方法栈和虚拟机栈赫尔为一。本地方法栈出现的异常为StackOverflowError和OutOfMemoryError异常。 Java堆Java堆(Java Heap)是Java虚拟机内存中最大的一块。堆被所有线程共享，在虚拟机启动时创建。堆的唯一目的就是存放对象实例。一般来说，几乎所有的对象实例都在堆上分配内存。Java堆是垃圾收集器管理的主要区域，因此又称为“GC堆”。(为什么莫名想到垃圾堆？)从内存回收角度由于收集器采用分代收集算法，故将Java堆细分为新生代，老生代；从内存分配角度将线程共享的堆划分为多个线程私有分配缓冲区。Java堆处于物理不连接的内存空间中，只要逻辑上连续即可。如果堆中没有内存完成实例分配，且堆无法再扩展时抛出OutOfMemoryError异常。 方法区方法区也是线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时候编译器编译后的代码等数据。Java虚拟机规范将方法区描述为堆的一个逻辑部分，但为与java堆进行区分，称它为Non-Heap(非堆)。由于HotSpot虚拟机用永久代来实现方法区，因而部分人习惯将方法区称为“永久代”。垃圾回收在方法区是较少出现的，这个区域内存回收主要目标是对常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 运行时常量池运行时常量池是方法区的一部分，常量池是包含在Class文件中的一项信息，用于存放编译期生成的各种自面量和符号引用，这部分信息将在类加载后存放到方法区的运行时常量池中。一般来说，除了保存Class文件中的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。运行时常量池与Class文件常量池相比具有动态性，并非时只有预置在Class文件中的常量池内容才能进入运行时常量池，运行期间也可以将新的常量放入池中，如String的intern()方法。当常量池无法再申请到内存时抛出OutOfMemoryError异常。 直接内存直接内存并不是虚拟机运行时数据区的一部分，但这部分内存被频繁的使用，也会OutOfMemoryError异常的出现。JDK1.4加入Input/Output类,引入基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，再通过Java堆中的DirectByteBuffer对象引用这块内存，以提高性能。它一般受到本机总内存与处理器寻址空间的限制，从而导致OutOfMemoryError异常。 本文主要参考《深入理解Java虚拟机——JVM高级特性与最佳实践》一书另参考文章:https://blog.csdn.net/u011116672/article/details/50994109]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>内存区域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之测略模式]]></title>
    <url>%2F2018%2F07%2F25%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言最近在读《Head First设计模式》一书，为加强记忆及便于日后查阅，在博客将自己的学习过程进行记录。谨以本篇策略模式作为自己博客的开篇章，并在后续过程中不断丰富自己的博客内容，欢迎各位进行浏览。另由于个人水平有限，博客内容难免有不当之处，欢迎各位进行批评指正。 问题现有一游戏SimDuck，游戏采用OO技术开发，其中会出现各种各样的鸭子，可以一边游泳一边呱呱叫。现在要对游戏内容进行丰富，使得鸭子能够飞起来。 解决思路思路1：继承在Duck父方法中加入fly()方法，简单快捷的实现鸭子的飞行 存在问题：若加入塑料橡皮鸭，木头诱饵鸭，继承Duck类之后，会出现橡皮鸭、诱饵鸭飞行的闹剧，因而在父类中加入fly()方法的思路不可行。思路2：改进继承Flyable与Quackable虽然解决了一些问题，但却造成代码无法复用，若有上百个鸭子类，每个都要修改飞行类，这简直就是一个噩梦。因而，我们要考虑其他的实现思路.思路3：策略模式实现接下来我们就用策略模式的方式实现SimDuck的需求。由上面分析可知，鸭子的quack()行为有“呱呱”、“吱吱”…… fly()行为有能自己飞的、不能飞的、依靠外力飞的…… 因而选择将这些不同的部分拿出来，建一组新类代表每个行为。在设计这些行为类的过程中，我们想要鸭子的行为可以动态的改变，并得到指定行为的鸭子实例。因而我们选择使用接口的方式构建鸭子行为，类图如下所示：这样的设计，可以让飞行与和呱呱叫的动作被其他对象复用，同时可以在新增行为的过程中，不会影响到既有的行为类，这样就有了继承的“复用”好处，却又没有继承带来的麻烦。整合鸭子的行为在Duck类中“加入两个实力变量”，分别为flyBehavior和quackBehavior,声明为接口类型，每个鸭子对象都会动态的设置变量以在运行时引用正确的行为类型。Dack类代码如下所示： public class Duck { QuackBehavior quackBehavior; FlyBehavior flyBehavior; public abstract void display(); public void performFly(){ flyBehavior.fly(); } public void performQuack(){ quackBehavior.quack; } public void setFlyBehavior(FlyBehavior fb){ flyBehavior = fb; } public void setQuackBehavior(QuackBehavior qb){ quackBehavior = qb; } } fly算法族的代码如下所示： public interface flyBehavior{ public void fly(); } public class FlyWithWings implents flyBehavior{ public void fly(){ System.out.println(&quot;I&apos;m flying&quot;); } } public class FlyNoWay implents flyBehavior{ public void fly(){ System.out.println(&quot;I can&apos;t fly&quot;); } } quack算法族的代码如下所示： public interface quackBehavior{ public void quack(); } public class Quack implents quackBehavior{ public void quack(){ System.out.println(&quot;Quack&quot;); } } public class MuteQuack implents quackBehavior{ public void quack(){ System.out.println(&quot;...silence...&quot;); } } public class Squeak implents quackBehavior{ public void quack(){ System.out.println(&quot;Squeak&quot;); } } 最后我们编辑一下测试类： public class MiniDuckSimulator{ public static void main(String[] args){ Duck mallard = new MallardDuck(); mallard.proformQuack(); mallard.profpormFly(); } } #####动态行为设定现在加入模型鸭，其通过火箭实现飞行 public class ModelDuck extends Duck{ public ModelDuck(){ quackBehavior = new Quack; flyBehavior = new FlyNoWay(); } public void display(){ System.out.printin(&quot;I;m a model duck&quot;); } } 新建FlyBehavior类型FlyRocketPowered public class FlyRocketPowered implements FlyBehavior{ public void fly(){ System.out.println(&quot;Im fly with rocket!&quot;); } } 修改测试类使得模型鸭具有火箭动力 public class MiniDuckSimulator{ public static void main(String[] args){ Duck mallard = new MallardDuck(); mallard.proformQuack(); mallard.profpormFly(); Duck model = new DuckModel(); model.proformFly(); model.setFlyBehavior(new FlyRocketPowered()); model.performFly(); } } 至此，我们已经完成了鸭子模拟器的设计，我们看一下整体的类结构，如下图所示： 策略模式定义了算法族，各个算法族分别封装起来，每个算法族内的类可以相互替换，使得算法的变化独立于算法使用者。 设计原则在上面的过程中，我们发现前两种思路存在缺点，而走在我们前面的优秀程序员们就针对这些缺点总结了相应的软件设计原则：设计原则一：分开变化与不变化即，找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。这个原则几乎是每个设计模式背后的精神所在，所有的模式都提供了一套方法让系统中的某部分改变不会影响其它部分。将会变化的部分封装起来，以后可以轻易的针对此部分进行改动或扩充，不影响其他部分。在SimDuck设计过程中我们将变化的fly与quack独立出来，使得整个系统变得更有弹性。设计原则之二：针对接口编程而不是针对实现编程在SimDuck原有的设计中，行为来自Duck父类的具体实现，或由子类继承接口后自行实现。这两种做法都是依赖于实现编程。在策略模式实现中我们将行为写在实现FlyBehavior和QuackBehavior的类中。针对接口编程的关键在于多态，利用多态，程序员可以实现针对超类型编程，执行时根据实际状况执行真正的行为。“针对超类型编程”可以更加准确的说为变量的声明类型应为超类型，通常为一个抽象类或接口，故只要具体实现次超类型的类所产生的对象，都可以指定给这个变量。即声明类时可以不用理会以后执行的真正的对象类型。设计原则之三：多用组合，少用继承使用组合建立系统具有很大的弹性，不仅可将算法族封装成类，更可以在运行时动态地改变行为，只要组合的对象符合正确的额接口标准即可。 策略模式总结使用方式一个系统有许多类，区分它们的只是他们直接的行为，在这种情况下，定义算法族,把它们封装成实现同一个接口的类, 使它们可相互替换。使用场景1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。2、一个系统需要动态地在几种算法中选择一种。3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。策略模式的优缺点策略模式的优点： 算法可以自由的切换，通过实现抽象策略，通过封装角色对其封装，保证对外提供“可自由切换”的策略。 避免使用多重条件判断，如果有多重策略，那么每个策略只需实现自己的方法，至于采用何种策略，可以通过其他模块决定。 扩展性良好，可以在现有的系统中任意的加入新的策略，只需继承IStrategy接口，符合OCP原则。 策略模式缺点： 策略类数量增多，每个策略都是一个类，复用的可能性很小，类数量增多 所有的策略都需要对外暴露，上层模块必须知道有哪些策略，然后才能知道采用哪种策略，可以通过使用工厂方法模式、代理模式和享元模式修正。 注意事项如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。 本文主要参考自《Head First设计模式》一书另参考文章：https://www.cnblogs.com/wolf-sun/p/3534573.htmlhttp://www.runoob.com/design-pattern/strategy-pattern.htmlhttps://www.cnblogs.com/zhanglei93/p/6081019.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>

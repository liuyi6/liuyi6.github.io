<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解jvm之Java内存区域]]></title>
    <url>%2F2018%2F07%2F25%2Fjvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Java虚拟机运行时数据区分为以下几个部分：方法区、虚拟机栈、本地方法栈、堆、程序计数器。如下图所示： 程序计数器程序计数器可看作当前线程所执行的字节码行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。Java虚拟机的多线程是通过线程轮流切换以分配处理执行时间的方式进行的，因而为了确保线程切换后能够恢复到正确的执行位置，每条线程都有一个独立的程序计数器，各个线程计数器独立存储，互不影响，这类内存区域称为“线程私有”内存。当线程执行Java方法时，计数器记录的时正在执行虚拟机字节码指令的地址；如果执行Native方法，则计数器值为空(Undefine)。程序计数器时唯一一个在Java虚拟机规范中没有任何规定OutOfMemoryError情况的内存区域。 Java虚拟机栈Java虚拟机栈也是线程私有的，生命周期与线程相同。Java虚拟机栈是描述Java方法执行的内存模型：每个方法执行时都会创建一个栈帧(方法运行期间的基础数据结构)，方法的执行过程对应着相应的栈帧在虚拟机中从入栈到出栈的过程。我们平时提到的栈就是虚拟机栈，也称为局部变量表部分。局部变量表存放了编译期间的各种基本数据类型、对象引用和returAdress类型。其中，double和long占两个局部变量空间(Slot)，其余数据类型占据一个。局部变量表所需内存是在编译期间完成分配的，当进入一个方法时，方法在帧中分配的局部变量空间大小是完全确定的，在方法运行期间局部变量表的大小不变。Java虚拟机栈规定了两种异常状况： 线程请求栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常。 虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时抛出OutOfMemoryError异常。 本地方法栈本地方法栈为虚拟机使用的Native方法服务，本地方法栈可根据虚拟机的具体要求自由实现。由的虚拟机(如Sun HotSpot虚拟机)直接将本地方法栈和虚拟机栈赫尔为一。本地方法栈出现的异常为StackOverflowError和OutOfMemoryError异常。 Java堆Java堆(Java Heap)是Java虚拟机内存中最大的一块。堆被所有线程共享，在虚拟机启动时创建。堆的唯一目的就是存放对象实例。一般来说，几乎所有的对象实例都在堆上分配内存。Java堆是垃圾收集器管理的主要区域，因此又称为“GC堆”。(为什么莫名想到垃圾堆？)从内存回收角度由于收集器采用分代收集算法，故将Java堆细分为新生代，老生代；从内存分配角度将线程共享的堆划分为多个线程私有分配缓冲区。Java堆处于物理不连接的内存空间中，只要逻辑上连续即可。如果堆中没有内存完成实例分配，且堆无法再扩展时抛出OutOfMemoryError异常。 方法区方法区也是线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时候编译器编译后的代码等数据。Java虚拟机规范将方法区描述为堆的一个逻辑部分，但为与java堆进行区分，称它为Non-Heap(非堆)。由于HotSpot虚拟机用永久代来实现方法区，因而部分人习惯将方法区称为“永久代”。垃圾回收在方法区是较少出现的，这个区域内存回收主要目标是对常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 运行时常量池运行时常量池是方法区的一部分，常量池是包含在Class文件中的一项信息，用于存放编译期生成的各种自面量和符号引用，这部分信息将在类加载后存放到方法区的运行时常量池中。一般来说，除了保存Class文件中的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。运行时常量池与Class文件常量池相比具有动态性，并非时只有预置在Class文件中的常量池内容才能进入运行时常量池，运行期间也可以将新的常量放入池中，如String的intern()方法。当常量池无法再申请到内存时抛出OutOfMemoryError异常。 直接内存直接内存并不是虚拟机运行时数据区的一部分，但这部分内存被频繁的使用，也会OutOfMemoryError异常的出现。JDK1.4加入Input/Output类,引入基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，再通过Java堆中的DirectByteBuffer对象引用这块内存，以提高性能。它一般受到本机总内存与处理器寻址空间的限制，从而导致OutOfMemoryError异常。 本文主要参考《深入理解Java虚拟机——JVM高级特性与最佳实践》一书另参考文章:https://blog.csdn.net/u011116672/article/details/50994109]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>内存区域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之测略模式]]></title>
    <url>%2F2018%2F07%2F25%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言最近在读《Head First设计模式》一书，为加强记忆及便于日后查阅，在博客将自己的学习过程进行记录。谨以本篇策略模式作为自己博客的开篇章，并在后续过程中不断丰富自己的博客内容，欢迎各位进行浏览。另由于个人水平有限，博客内容难免有不当之处，欢迎各位进行批评指正。 问题现有一游戏SimDuck，游戏采用OO技术开发，其中会出现各种各样的鸭子，可以一边游泳一边呱呱叫。现在要对游戏内容进行丰富，使得鸭子能够飞起来。 解决思路思路1：继承在Duck父方法中加入fly()方法，简单快捷的实现鸭子的飞行 存在问题：若加入塑料橡皮鸭，木头诱饵鸭，继承Duck类之后，会出现橡皮鸭、诱饵鸭飞行的闹剧，因而在父类中加入fly()方法的思路不可行。思路2：改进继承Flyable与Quackable虽然解决了一些问题，但却造成代码无法复用，若有上百个鸭子类，每个都要修改飞行类，这简直就是一个噩梦。因而，我们要考虑其他的实现思路.思路3：策略模式实现接下来我们就用策略模式的方式实现SimDuck的需求。由上面分析可知，鸭子的quack()行为有“呱呱”、“吱吱”…… fly()行为有能自己飞的、不能飞的、依靠外力飞的…… 因而选择将这些不同的部分拿出来，建一组新类代表每个行为。在设计这些行为类的过程中，我们想要鸭子的行为可以动态的改变，并得到指定行为的鸭子实例。因而我们选择使用接口的方式构建鸭子行为，类图如下所示：这样的设计，可以让飞行与和呱呱叫的动作被其他对象复用，同时可以在新增行为的过程中，不会影响到既有的行为类，这样就有了继承的“复用”好处，却又没有继承带来的麻烦。整合鸭子的行为在Duck类中“加入两个实力变量”，分别为flyBehavior和quackBehavior,声明为接口类型，每个鸭子对象都会动态的设置变量以在运行时引用正确的行为类型。Dack类代码如下所示： public class Duck { QuackBehavior quackBehavior; FlyBehavior flyBehavior; public abstract void display(); public void performFly(){ flyBehavior.fly(); } public void performQuack(){ quackBehavior.quack; } public void setFlyBehavior(FlyBehavior fb){ flyBehavior = fb; } public void setQuackBehavior(QuackBehavior qb){ quackBehavior = qb; } } fly算法族的代码如下所示： public interface flyBehavior{ public void fly(); } public class FlyWithWings implents flyBehavior{ public void fly(){ System.out.println(&quot;I&apos;m flying&quot;); } } public class FlyNoWay implents flyBehavior{ public void fly(){ System.out.println(&quot;I can&apos;t fly&quot;); } } quack算法族的代码如下所示： public interface quackBehavior{ public void quack(); } public class Quack implents quackBehavior{ public void quack(){ System.out.println(&quot;Quack&quot;); } } public class MuteQuack implents quackBehavior{ public void quack(){ System.out.println(&quot;...silence...&quot;); } } public class Squeak implents quackBehavior{ public void quack(){ System.out.println(&quot;Squeak&quot;); } } 最后我们编辑一下测试类： public class MiniDuckSimulator{ public static void main(String[] args){ Duck mallard = new MallardDuck(); mallard.proformQuack(); mallard.profpormFly(); } } #####动态行为设定现在加入模型鸭，其通过火箭实现飞行 public class ModelDuck extends Duck{ public ModelDuck(){ quackBehavior = new Quack; flyBehavior = new FlyNoWay(); } public void display(){ System.out.printin(&quot;I;m a model duck&quot;); } } 新建FlyBehavior类型FlyRocketPowered public class FlyRocketPowered implements FlyBehavior{ public void fly(){ System.out.println(&quot;Im fly with rocket!&quot;); } } 修改测试类使得模型鸭具有火箭动力 public class MiniDuckSimulator{ public static void main(String[] args){ Duck mallard = new MallardDuck(); mallard.proformQuack(); mallard.profpormFly(); Duck model = new DuckModel(); model.proformFly(); model.setFlyBehavior(new FlyRocketPowered()); model.performFly(); } } 至此，我们已经完成了鸭子模拟器的设计，我们看一下整体的类结构，如下图所示： 策略模式定义了算法族，各个算法族分别封装起来，每个算法族内的类可以相互替换，使得算法的变化独立于算法使用者。 设计原则在上面的过程中，我们发现前两种思路存在缺点，而走在我们前面的优秀程序员们就针对这些缺点总结了相应的软件设计原则：设计原则一：分开变化与不变化即，找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。这个原则几乎是每个设计模式背后的精神所在，所有的模式都提供了一套方法让系统中的某部分改变不会影响其它部分。将会变化的部分封装起来，以后可以轻易的针对此部分进行改动或扩充，不影响其他部分。在SimDuck设计过程中我们将变化的fly与quack独立出来，使得整个系统变得更有弹性。设计原则之二：针对接口编程而不是针对实现编程在SimDuck原有的设计中，行为来自Duck父类的具体实现，或由子类继承接口后自行实现。这两种做法都是依赖于实现编程。在策略模式实现中我们将行为写在实现FlyBehavior和QuackBehavior的类中。针对接口编程的关键在于多态，利用多态，程序员可以实现针对超类型编程，执行时根据实际状况执行真正的行为。“针对超类型编程”可以更加准确的说为变量的声明类型应为超类型，通常为一个抽象类或接口，故只要具体实现次超类型的类所产生的对象，都可以指定给这个变量。即声明类时可以不用理会以后执行的真正的对象类型。设计原则之三：多用组合，少用继承使用组合建立系统具有很大的弹性，不仅可将算法族封装成类，更可以在运行时动态地改变行为，只要组合的对象符合正确的额接口标准即可。 策略模式总结使用方式一个系统有许多类，区分它们的只是他们直接的行为，在这种情况下，定义算法族,把它们封装成实现同一个接口的类, 使它们可相互替换。使用场景1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。2、一个系统需要动态地在几种算法中选择一种。3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。策略模式的优缺点策略模式的优点： 算法可以自由的切换，通过实现抽象策略，通过封装角色对其封装，保证对外提供“可自由切换”的策略。 避免使用多重条件判断，如果有多重策略，那么每个策略只需实现自己的方法，至于采用何种策略，可以通过其他模块决定。 扩展性良好，可以在现有的系统中任意的加入新的策略，只需继承IStrategy接口，符合OCP原则。 策略模式缺点： 策略类数量增多，每个策略都是一个类，复用的可能性很小，类数量增多 所有的策略都需要对外暴露，上层模块必须知道有哪些策略，然后才能知道采用哪种策略，可以通过使用工厂方法模式、代理模式和享元模式修正。 注意事项如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。 本文主要参考自《Head First设计模式》一书另参考文章：https://www.cnblogs.com/wolf-sun/p/3534573.htmlhttp://www.runoob.com/design-pattern/strategy-pattern.htmlhttps://www.cnblogs.com/zhanglei93/p/6081019.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建springboot项目]]></title>
    <url>%2F2018%2F07%2F24%2Fspringboot%E5%BB%BA%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[spring boot的核心功能 独立运行的Spring项目：可以以jar包形式独立运行，通过java -jar xx.jar即可运行 内嵌Servlet容器：可以选择内嵌Tomcat、Jetty等 提供starter简化maven配置：一个maven项目，使用了spring-boot-starter-web时，会自动加载Spring Boot的依赖包 自动配置Spring：Spring Boot会根据在类路径中的jar包、类，为jar包中的类自动配置Bean 准生产的应用监控：提供基于http、ssh、telnet对运行时的项目进行监控 无代码生成和xml配置：主要通过条件注解来实现 手工搭建spring boot项目 手工构建maven项目 任意IDE新建空maven项目 修改pom.xml添加Spring Boot的父级依赖Spring-boot-starter-parent，添加之后这个项目就是 一个Spring Boot项目了&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; Spring-boot-starter-parent是一个特殊的starter，用来提供相关的maven默认依赖，使用之后，常用的包依赖可以省略version标签 修改pom.xml添加web支持的starter &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 添加Spring boot编译插件 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 在根包目录下生成一个入口类，添加一个测试控制器简单测试一下 package com.wisely.ch5_2_4; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @SpringBootApplication //Spring Boot核心注解，用于开启自动配置 public class DemoApplication { @RequestMapping(&quot;/&quot;) String index(){ return &quot;Hello Spring Boot&quot;; } public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } }]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式简介]]></title>
    <url>%2F2018%2F07%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E8%AE%B2%2F</url>
    <content type="text"><![CDATA[设计模式的分类目前共有23种设计模式，这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。 创建型模式 - 5种这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern） 单例模式（Singleton Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern） 结构型模式 - 8种这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 过滤器模式（Filter、Criteria Pattern） 组合模式（Composite Pattern） 装饰器模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern） 行为型模式 - 12种这些设计模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 空对象模式（Null Object Pattern） 策略模式（Strategy Pattern） 模板模式（Template Pattern） 访问者模式（Visitor Pattern） J2EE模式 - 8种这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 MVC 模式（MVC Pattern） 业务代表模式（Business Delegate Pattern） 组合实体模式（Composite Entity Pattern） 数据访问对象模式（Data Access Object Pattern） 前端控制器模式（Front Controller Pattern） 拦截过滤器模式（Intercepting Filter Pattern） 服务定位器模式（Service Locator Pattern） 传输对象模式（Transfer Object Pattern） 可以用下图描述设计模式之间的关系： 设计模式的六大原则 开闭原则（Open Close Principle）开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 里氏代换原则（Liskov Substitution Principle）里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 依赖倒转原则（Dependence Inversion Principle）这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 迪米特法则，又称最少知道原则（Demeter Principle）最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle）合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。 此文参考自：http://www.runoob.com/design-pattern/design-pattern-intro.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>

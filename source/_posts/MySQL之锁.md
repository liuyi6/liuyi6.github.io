
## 一、MySQL锁简介

MySQL锁按照不同的角度有不同的分类方式：

按照锁的功能分为：共享读锁和排他写锁

按照锁的实现方式分为：悲观锁和乐观锁

按照锁的粒度分为：全局锁、表级锁、行级锁，其中：

* 全局锁：所得是整个database，由MySQL的SQL layer层实现。使用场景：数据备份。
* 表级锁：锁的是整个table，由MySQL的SQL layer层实现。
* 行级锁：锁的是某N行数据，也可能是行之间的间隙，由某些存储引擎实现，只有InnoDB和xtradb存储引擎支持。

表级锁与行级锁的区别：

- 表级锁：开销小，加锁快；不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。
- 行级锁：开销大，加锁慢；会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度最高。

下面主要从锁的粒度的分类方式进行说明。

## 二、MySQL表级锁

表级锁由MySQL服务层实现，MySQL的表级锁有两种：表锁和元数据锁MDL（meta data lock）

MySQL 实现的表级锁定的争用状态变量：

```mysql
show status like 'table%';
```

其中，`table_locks_immediate`：产生表级锁定的次数；`table_locks_waited`：出现表级锁定争用而发生等待的次数；

### 1、表锁

表锁有两种表现形式：表共享读锁（Table Read Lock）、表独占写锁（Table Write Lock）

手动增加表锁：

```mysql
lock table 表名称 read(write),表名称2 read(write)，其他;
```

查看表锁情况：

```mysql
show open tables;
```

删除表锁：

```mysql
unlock tables;
```

### 2、表锁实例



### 3、元数据锁MDL

MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。

当一个查询正在遍历一个表中的数据时，另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上。

* 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
* 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个
  表加字段，其中一个要等另一个执行完才能开始执行。

### 4、元数据锁示例



## 三、MySQL行级锁

### 1、行级锁介绍

MySQL行级锁是由存储引擎实现的，这里主要对InnoDB的行级锁进行说明。

InnoDB的行级锁按照锁定范围分为三种：

* 记录锁(Record Locks)：锁死索引中的一条记录
* 间隙锁(Gap Locks)：锁定索引记录中间的值，锁定第一个索引记录之前的值或左后一个索引记录之后的值
* Next-key Locks：是索引记录上的记录锁与索引之间间隙锁的组合

InnoDB的行级锁，按照功能分为两种：

- 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。 
- 排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；

对于普通SELECT语句，InnoDB不会加任何锁，事务可以通过以下语句显示给记录集加共享锁或排他锁

手动添加共享锁（S）:

```mysql
SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
```

手动添加排它锁（X）:

```mysql
SELECT * FROM table_name WHERE ... FOR UPDATE
```

InnoDB也实现了表级锁，也就是意向锁，意向锁是mysql内部使用的，不需要用户干预。

- 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
- 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁

意向锁和行锁可以共存，意向锁的主要作用是为了【全表更新数据】时的性能提升。否则在全表更新数据时，需要先检索该范是否某些记录上面有行锁。

共享锁（S）排他锁（X）意向共享锁（IS）意向排他锁（IX）共享锁（S）兼容冲突兼容冲突排他锁（X）冲突冲突冲突冲突意向共享锁（IS）兼容冲突兼容兼容意向排他锁（IX）冲突冲突兼容兼容

|                  | 共享锁（S） | 排他锁（X） | 意向共享锁（IS） | 意向排他锁（IX） |
| :--------------: | :---------: | :---------: | :--------------: | :--------------: |
|   共享锁（S）    |    兼容     |    冲突     |       兼容       |       冲突       |
|   排他锁（X）    |    冲突     |    冲突     |       冲突       |       冲突       |
| 意向共享锁（IS） |    兼容     |    冲突     |       兼容       |       兼容       |
| 意向排他锁（IX） |    冲突     |    冲突     |       兼容       |       兼容       |

InnoDB行锁是通过给索引上的索引项加锁来实现的，因此InnoDB这种行锁实现特点意味着：只有通过索引条件检索的数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！

Innodb所使用的行级锁定争用状态查看：

```mysql
show status like 'innodb_row_lock%'
```

其中：

- Innodb_row_lock_current_waits：当前正在等待锁定的数量；
- Innodb_row_lock_time：从系统启动到现在锁定总时间长度；
- Innodb_row_lock_time_avg：每次等待所花平均时间； 
- Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间； 
- Innodb_row_lock_waits：系统启动后到现在总共等待的次数；

对于这5个状态变量，比较重要的主要是：Innodb_row_lock_time_avg（等待平均时长）、Innodb_row_lock_waits（等待总次数）、Innodb_row_lock_time（等待总时长）三项

### 2、InnoDB行级锁演示

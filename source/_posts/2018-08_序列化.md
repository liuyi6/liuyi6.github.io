---
title: 理解序列化
date: 2018-08-16 19:54:19
tags: [Java进阶]
categories: Java进阶
---
# 前言
Java对象是在JVM中产生的，若要将其进行传输或保存到硬盘，就要将对象转换为可传输的文件流。而目前Java对象的转换方式有：

 1. 利用Java的序列化功能序列成字节(字节流)，一般是需要加密传输时使用。
 2. 将对象包装成JSON字符串（字符流），一般使用JSON工具进行转换 。
 3. protoBuf工具(二进制)，性能好，效率高，字节数很小，网络传输节省IO。但二进制格式可读性差。

# 序列化基础
序列化：Serialization（序列化）是一种将对象以一连串的字节描述的过程
反序列化：反序列化deserialization是一种将这些字节重建成一个对象的过程
序列化机制算法：

 1. 所有保存到磁盘中的对象都有一个序列化编号
 2. 当程序试图序列化一个对象时，程序先检查该对象是否已经被序列化过。如果从未被序列化过，系统就会将该对象转换成字节序列并输出；如果已经序列化过，将直接输出一个序列化编号。

## 应用场景
**持久化对象**：把对象的字节序列永久地保存到硬盘上
Java中能够在JVM中创建可复用的Java对象，但只用JVM运行时，对象才能存在，即对象的生命周期不可能比JVM生命周期更长。但实际情况可能遇到需要当JVM停止时也需要对象依旧存在，因而就需要对对象进行持久化，并在JVM停止的情况下，能够对保存的对象进行持久化。
**对象复制**：通过序列化，将对象保存在内存中，可以再通过此数据得到多个对象的副本。
**网络传输对象**：在网络上传送对象的字节序列网络传输过程中，会将数据转换为字节序列化的形式进行传输。发送方需将Java对象转换为字节序列，进行传输；接收方需把字节序列恢复为Java对象。
## 序列化实现
实现Serializable，Externalizable两个接口之一的类的对象才能被序列化，他们的区别主要有：

 1. Serializable序列化时不会调用默认的构造器，而Externalizable序列化时会调用默认构造器的！！！
 2. Serializable：一个对象想要被序列化，那么它的类就要实现 此接口，这个对象的所有属性（包括private属性、包括其引用的对象）都可以被序列化和反序列化来保存、传递。Externalizable：他是Serializable接口的子类，有时我们不希望序列化那么多，可以使用这个接口，这个接口的writeExternal()和readExternal()方法可以指定序列化哪些属性。

## 序列化对象注意事项

 1. 对象的类名、属性都会被序列化；而方法、static属性（静态属性）、transient属性（即瞬态属性）都不会被序列化（这也就是第4条注意事项的原因）虽然加static也能让某个属性不被序列化，但static不这么用
 1. 要序列化的对象的引用属性也必须是可序列化的，否则该对象不可序列化，除非以transient关键字修饰该属性使其不用序列化。
 1.  反序列化地象时必须有序列化对象生成的class文件（很多没有被序列化的数据需要从class文件获取）
 1. 当通过文件、网络来读取序列化后的对象时，必须按实际的写入顺序读取。

## 序列化实例
SerializeTest类实现了序列化接口，对象进行序列化，反序列化，最后查看序列化对象保存内容。项目代码如下：

    public class SerializeTest implements Serializable {

        private static final long serialVersionUID = 1L;
        public int num = 1390;

        public  void serialized() {
            try {  
                FileOutputStream fos = new FileOutputStream("serialize.obj");  
                ObjectOutputStream oos = new ObjectOutputStream(fos);  
                SerializeTest serialize = new SerializeTest();  
                oos.writeObject(serialize);  
                oos.flush();  
                oos.close();
                fos.close();  
                System.out.println("------序列化结束------"); 
            } catch (FileNotFoundException e) {  
                e.printStackTrace();  
            } catch (IOException e) {  
                e.printStackTrace();  
            }  
        }

        public void deserialized()  
        {  
            SerializeTest serialize = null;  
            try  
            {  
                FileInputStream fis = new FileInputStream("serialize.obj");  
                ObjectInputStream ois = new ObjectInputStream(fis);  

                serialize = (SerializeTest) ois.readObject();  
                ois.close();  
                fis.close();  
                System.out.println("------反序列化结束------");  
            }  
            catch (ClassNotFoundException | IOException e)  
            {  
                e.printStackTrace();  
            }  
            System.out.println(serialize.num);  
        }

        public static void main(String[] args)   {  
            SerializeTest serialize = new SerializeTest();  
            serialize.serialized();  
            serialize.deserialized();  
        } 
    }

序列化对象读取：

    public class ReadSerialize {
        public static void main(String[] args) {
            try {  
                File file = new File("serialize.obj");  
                InputStream in = new FileInputStream(file);  
                byte buff[] = new byte[1024];  
                int len = 0;  
                while((len = in.read(buff)) != -1)  
                {  
                    for(int i=0;i<len;i++)  
                    {  
                        System.out.printf("%02X ",buff[i]);  
                    }  
                    System.out.println();  
                }  
            } catch (FileNotFoundException e) {  
                e.printStackTrace();  
            } catch (IOException e) {  
                e.printStackTrace();  
            }  
        }
    }

运行结果

    AC ED 00 05 73 
    72 00 20 63 6F 6D 2E 6C 75 69 73 2E 73 65 72 69 61 6C 69 7A 65 2E 53 65 72 69 61 6C 69 7A 65 54 65 73 74 00 00 00 00 00 00 00 01 02 00 01
    49 00 03 6E 75 6D 
    78 70 
    00 00 05 6E

注：%02x     格式控制: 以十六进制输出,2为指定的输出字段的宽度.如果位数小于2,则左端补0
**结果分析**：
**第一部分是序列化文件头**

    AC ED：STREAM_MAGIC声明使用了序列化协议
    00 05：STREAM_VERSION序列化协议版本
    73：TC_OBJECT声明这是一个新的对象
** 第二部分是序列化类的描述**

    72：TC_CLASSDESC声明这里开始一个新class
    00 20：class名字的长度是32字节
    63 6F 6D 2E 6C 75 69 73 2E 73 65 72 69 61 6C 69 7A 65 2E 53 65 72 69 61 6C 69 7A 65 54 65 73 74:类名（ASCII码：com.luis.serialize.SerializeTest）
    00 00 00 00 00 00 00 01： SerialVersionUID
    02：标记号，改值声明改对象支持序列化
    00 01：该类所包含的域的个数为1
**第三部分是对象中各个属性项的描述**

    49：域类型，代表I,表示Int类型（又如：44，查ASCII码表为D，代表Double类型）
    00 03：域名字的长度，为3
    6E 75 6D: num属性的名称
** 第四部分输出该对象父类信息描述**

    这里没有父类，如果有，则数据格式与第二部分一样
    78：TC_ENDBLOCKDATA，对象块接收标志
    70：TC_NULL，说明没有其他超类的标志
** 第五部分输出对象的属性的实际值**

    如果属性项是一个对象，那么这里还将序列化这个对象，规则和第2部分一样。
    00 00 05 6E：1390的值
需要注意的是，**序列化前后对象是不同的，它们的对象地址不同**
# 序列化实际应用
## 序列化 ID
一般系统都会要求实现serialiable接口的类显式的生明一个serialVersionUID，显式定义serialVersionUID有如下两种用途：

 1. 希望类的不同版本对序列化兼容时，需要确保类的不同版本具有相同的serialVersionUID；
 2. 不希望类的不同版本对序列化兼容时，需要确保类的不同版本具有不同的serialVersionUID。

虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID = 1L）。若两个类的功能代码完全一致，但是序列化 ID 不同，他们无法相互序列化和反序列化。如下所示：

    public class SerializeDemo implements Serializable {
        private static final long serialVersionUID = 1L;

        private String name;
        private Integer age;

        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
        public Integer getAge() {
            return age;
        }
        public void setAge(Integer age) {
            this.age = age;
        }
    }

    public class SerializeDemo implements Serializable {
        private static final long serialVersionUID = 2L;

        private String name;
        private Integer age;

        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
        public Integer getAge() {
            return age;
        }
        public void setAge(Integer age) {
            this.age = age;
        }
    }
序列化ID在 Eclipse下提供了两种生成策略，一个是固定的 1L，一个是随机生成一个不重复的 long 类型数据（实际上是使用 JDK 工具生成），如果没有特殊需求，就是用默认的 1L 就可以，这样可以确保代码一致时反序列化成功。随机的生成序列化，通过改变序列化 ID 可以用来限制某些用户的使用。
### 应用实例
Façade 模式，它是为应用程序提供统一的访问接口，Client 端通过 Façade Object 才可以与业务逻辑对象进行交互。而客户端的 Façade Object 不能直接由 Client 生成，而是需要 Server 端生成，然后序列化后通过网络将二进制对象数据传给 Client，Client 负责反序列化得到 Façade 对象。该模式可以使得 Client 端程序的使用需要服务器端的许可，同时 Client 端和服务器端的 Façade Object 类需要保持一致。当服务器端想要进行版本更新时，只要将服务器端的 Façade Object 类的序列化 ID 再次生成，当 Client 端反序列化 Façade Object 就会失败，也就是强制 Client 端从服务器端获取最新程序。
## 静态变量的序列化
序列化保存的是对象的状态，静态变量属于类的状态，因此 序列化并不保存静态变量。
如下，在SerializeStatic中，存入时num为8，当读取出来时为10.

    public class SerializeStatic implements Serializable {
        private static final long serialVersionUID = 1L;

        public static int num = 8;
        public static void main(String[] args) {
             try {
                    //初始时staticVar为5
                    ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("result.obj"));
                    out.writeObject(new SerializeStatic());
                    out.close();

                    //序列化后修改为10
                    SerializeStatic.num = 10;

                    ObjectInputStream oin = new ObjectInputStream(new FileInputStream("result.obj"));
                    SerializeStatic t = (SerializeStatic) oin.readObject();
                    oin.close();

                    //再读取，通过t.staticVar打印新的值
                    System.out.println(t.num);

                } catch (Exception e) {
                    e.printStackTrace();
                }
        }
    }
## 父类的序列化与 Transient 关键字
当对某个对象进行序列化时，系统会自动将该对象的所有属性依次进行序列化，如果某个属性引用到别一个对象，则被引用的对象也会被序列化。如果被引用的对象的属性也引用了其他对象，则被引用的对象也会被序列化。 这就是递归序列化。有时，我们并不希望出现递归序列化，或是某个存敏感信息（如银行密码）的属性不被序列化，我们就可通过transient关键字修饰该属性来阻止被序列化。
一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable 接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就需要有默认的无参的构造函数。 在父类没有实现Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取 父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都 是默认声明的值，如 int 型的默认是 0，string型的默认是 null。
根据以上特性在具体的应用过程中可根据父类对象序列化的规则，我们可以将不需要被序列化的字段抽取出来放到父类中，子类实现 Serializable 接口，父类不实现，根据父类序列化规则，父类的字段数据将不被序列化。

## 对敏感字段加密
服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全，这时可以使用transient关键字阻止序列化，这种方法虽然简单方便，但被它修饰的属性被完全隔离在序列化机制之外，导致了在反序列化时无法获取该属性的值，而通过在需要序列化的对象的Java类里加入writeObject()方法与readObject()方法可以控制如何序列化各属性，甚至完全不序列化某些属性（此时就transient一样）。
在序列化过程中，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感字段的加密工作。

    public class EncryptPwd implements Serializable{
        private static final long serialVersionUID = 1L;
        private String password = "luis";

        public String getPassword() {
            return password;
        }

        private void writeObject(ObjectOutputStream out) {
            try {
                PutField putFields = out.putFields();
                System.out.println("原密码:" + password);
                password = "encryption";//模拟加密
                putFields.put("password", password);
                System.out.println("加密后的密码" + password);
                out.writeFields();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        private void readObject(ObjectInputStream in) {
            try {
                GetField readFields = in.readFields();
                Object object = readFields.get("password", "");
                System.out.println("要解密的字符串:" + object.toString());
                password = "luis";//模拟解密,需要获得本地的密钥
            } catch (IOException e) {
                e.printStackTrace();
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            }
        }

        public static void main(String[] args) {
            try {
                ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("result.obj"));
                out.writeObject(new EncryptPwd());
                out.close();

                ObjectInputStream oin = new ObjectInputStream(new FileInputStream(
                        "result.obj"));
                EncryptPwd t = (EncryptPwd) oin.readObject();
                System.out.println("解密后的字符串:" + t.getPassword());
                oin.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
运行结果：

    原密码:luis
    加密后的密码encryption
    要解密的字符串:encryption
    解密后的字符串:luis
### 应用实例
RMI 技术是完全基于 Java 序列化技术的，服务器端接口调用所需要的参数对象来至于客户端，它们通过网络相互传输。这就涉及 RMI 的安全传输的问题。一些敏感的字段，如用户名密码（用户登录时需要对密码进行传输），我们希望对其进行加密，这时，就可以采用上面的方法在客户端对密 码进行加密，服务器端进行解密，确保数据传输的安全性。

## 序列化存储规则
在下面的SerializeRule中，同一对象两次写入文件，并打印出写入一次对象与写入两次对象的存储大小，并将反序列化出的两个对象进行对比。

    public class SerializeRule implements Serializable{
        private static final long serialVersionUID = 1L;

        public static void main(String[] args) {
            try {
                ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("result.obj"));
                SerializeRule rule = new SerializeRule();
                // 试图将对象两次写入文件
                out.writeObject(rule);
                out.flush();
                System.out.println(new File("result.obj").length());
                out.writeObject(rule);
                out.close();
                System.out.println(new File("result.obj").length());

                ObjectInputStream oin = new ObjectInputStream(new FileInputStream("result.obj"));
                // 从文件依次读出两个文件
                SerializeRule r1 = (SerializeRule) oin.readObject();
                SerializeRule r2 = (SerializeRule) oin.readObject();
                oin.close();
                // 判断两个引用是否指向同一个对象
                System.out.println(r1 == r2);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

运行结果：

    53
    58
    true
由结果发现，存入两次对象，文件并非预期的那样为两倍文件的大小，且反序列化生成的两个对象为ture。原来，Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用，上面增加的 5 字节的存储空间就是新增引用和一些控制信息的空间。反序列化时，恢复引用关系，使得清单r1与r2指向唯一的对象，二者相等，输出 true。该存储规则极大的节省了存储空间。

参考自：
本文中有极大部分参考了[深入理解JAVA序列化](https://www.cnblogs.com/wxgblogs/p/5849951.html)与[Java对象序列化详解](https://blog.csdn.net/zcl_love_wx/article/details/52126876)的内容
https://blog.csdn.net/zcl_love_wx/article/details/52126876
https://www.cnblogs.com/wade-luffy/p/5915499.html
https://www.cnblogs.com/wxgblogs/p/5849951.html

---
title: 双亲委派策略与自定义类加载器
date: 2018-08-24 19:54:19
tags: [Java进阶]
categories: Java进阶
---
# 类加载器
类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。
任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在java虚拟机中的唯一性。
从JVM的角度来说，有两种类加载器：启动类加载器，其他类加载器

 - 启动类加载器（Bootstrap ClassLoader）：由C++语言实现（针对HotSpot）,负责将存放在&lt;JAVA_HOME>\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中。
 - 其他类加载器：由Java语言实现，继承自抽象类ClassLoader。如：
    - 扩展类加载器（Extension ClassLoader）：负责加载&lt;JAVA_HOME>\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。
    - 应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。

应用程序由这三种类加载器互相配合进行加载的，如果有必须，还可以加入自己定义的类加载器。这些类加载器之间的关系一般如下图：
![](/images/2018-8-1/double_jvm_load.png)
上图中展示的类加载器之间的层次关系，就称为类加载器的双亲委派模型(Parents Delegation Model)。
 # 双亲委派模型
双亲委派模型除了Bootstrap ClassLoader外，其余的类加载器都要有自己的父加载器。子加载器通过组合来复用父加载器的代码，而不是使用继承。
双亲委派模型的过程：

 1. 当Application ClassLoader 收到一个类加载请求时，他首先不会自己去尝试加载这个类，而是将这个请求委派给父类加载器Extension ClassLoader去完成。  
 2. 当Extension ClassLoader收到一个类加载请求时，他首先也不会自己去尝试加载这个类，而是将请求委派给父类加载器Bootstrap ClassLoader去完成。  
 3. 如果Bootstrap ClassLoader加载失败(在&lt;JAVA_HOME>\lib中未找到所需类)，就会让Extension ClassLoader尝试加载。
 4. 如果Extension ClassLoader也加载失败，就会使用Application ClassLoader加载。
 5. 如果Application ClassLoader也加载失败，就会使用自定义加载器去尝试加载。
 6. 如果均加载失败，就会抛出ClassNotFoundException异常。

其中，进行类加载的请求委派过程是一个从下到上的过程；进行尝试类加载的过程是一个从上到下的过程。

 ## 双亲委派模型的优点
Java类伴随其类加载器具备了带有优先级的层次关系，确保了在各种加载环境的加载顺序。  保证了运行的安全性，防止不可信类扮演可信任的类。
如，Java中的Object类，它存放在rt.jar之中,无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object在各种类加载环境中都是同一个类。如果不采用双亲委派模型，那么由各个类加载器自己取加载的话，那么系统中会存在多种不同的Object类。
 ## 双亲委派模型的破坏 
 ### 第一次破坏
由于双亲委派模型是在JDK1.2之后才被引入的，而类加载器和抽象类java.lang.ClassLoader则在JDK1.0时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。在此之前，用户去继承java.lang.ClassLoader的唯一目的就是为了重写loadClass()方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法唯一逻辑就是去调用自己的loadClass()。
 ### 第二次破坏
双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的同一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API，但世事往往没有绝对的完美。
如果基础类又要调用回用户的代码，那该么办？
一个典型的例子就是JNDI服务，JNDI现在已经是Java的标准服务，
它的代码由启动类加载器去加载（在JDK1.3时放进去的rt.jar），但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者的代码，但启动类加载器不可能“认识”这些代码。
为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，他将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。
有了线程上下文加载器，JNDI服务就可以使用它去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI、JDBC、JCE、JAXB和JBI等。
 ### 第三次破坏
双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换、模块热部署等，简答的说就是机器不用重启，只要部署上就能用。
OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi幻境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当受到类加载请求时，OSGi将按照下面的顺序进行类搜索：
1）将java.＊开头的类委派给父类加载器加载。
2）否则，将委派列表名单内的类委派给父类加载器加载。
3）否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。
4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。
5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。
6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。
7）否则，类加载器失败

 # 自定义类加载器
 ## 几个函数
 ### loadClass
loadClass的默认实现如下：

	public Class<?> loadClass(String name) throws ClassNotFoundException {
			return loadClass(name, false);
	}



再看看loadClass(String name, boolean resolve)函数：

	protected Class<?> loadClass(String name, boolean resolve)
		throws ClassNotFoundException
	{
		synchronized (getClassLoadingLock(name)) {
			// First, check if the class has already been loaded
			Class c = findLoadedClass(name);
			if (c == null) {
				long t0 = System.nanoTime();
				try {
					if (parent != null) {
						c = parent.loadClass(name, false);
					} else {
						c = findBootstrapClassOrNull(name);
					}
				} catch (ClassNotFoundException e) {
					// ClassNotFoundException thrown if class not found
					// from the non-null parent class loader
				}

				if (c == null) {
					// If still not found, then invoke findClass in order
					// to find the class.
					long t1 = System.nanoTime();
					c = findClass(name);

					// this is the defining class loader; record the stats
					sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
					sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
					sun.misc.PerfCounter.getFindClasses().increment();
				}
			}
			if (resolve) {
				resolveClass(c);
			}
			return c;
		}
	}
从上面代码可以明显看出，loadClass(String, boolean)函数即实现了双亲委派模型！整个大致过程如下：

1. 首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。
1. 如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用parent.loadClass(name, false);）.或者是调用bootstrap类加载器来加载。
1. 如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的findClass方法来完成类加载。

换句话说，**如果自定义类加载器，就必须重写findClass方法！**

 ### findClass
findClass的默认实现如下：

    protected Class<?> findClass(String name) throws ClassNotFoundException {
            throw new ClassNotFoundException(name);
    }

可以看出，抽象类ClassLoader的findClass函数默认是抛出异常的。而前面我们知道，loadClass在父加载器无法加载类的时候，就会调用我们自定义的类加载器中的findeClass函数，因此我们必须要在loadClass这个函数里面实现将一个指定类名称转换为Class对象.

 ### defineClass
defineClass主要的功能是：将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节数组。如，假设class文件是加密过的，则需要解密后作为形参传入defineClass函数。
defineClass的默认实现如下：

	protected final Class<?> defineClass(String name, byte[] b, int off, int len)
			throws ClassFormatError  {
			return defineClass(name, b, off, len, null);
	}

 ## 函数调用过程
函数调用过程如下图所示：
![](/images/2018-8-1/our_load_streams.png)
 ## 简单示例
项目参考自：https://www.cnblogs.com/wxd0108/p/6681618.html
定义一个待加载的普通Java类:Test.java。放在com.luis.test包下:
	package com.luis.test;

	public class Test {
		public void hello() {
			System.out.println(我是由 " + getClass().getClassLoader().getClass()+ " 加载进来的");
		}
	}

待Test.java编译后，请把Test.class文件拷贝走，再将Test.java删除。若把Test.class存放在当前项目中，根据双亲委派模型可知，会通过sun.misc.Launcher$AppClassLoader类加载器加载。为了让我们自定义的类加载器加载，我们把Test.class文件放入到其他目录。

	public class Main {
		static class MyClassLoader extends ClassLoader {
			private String classPath;

			public MyClassLoader(String classPath) {
				this.classPath = classPath;
			}

			private byte[] loadByte(String name) throws Exception {
				name = name.replaceAll("\\.", "/");
				FileInputStream fis = new FileInputStream(classPath + "/" + name
						+ ".class");
				int len = fis.available();
				byte[] data = new byte[len];
				fis.read(data);
				fis.close();
				return data;

			}

			protected Class<?> findClass(String name) throws ClassNotFoundException {
				try {
					byte[] data = loadByte(name);
					return defineClass(name, data, 0, data.length);
				} catch (Exception e) {
					e.printStackTrace();
					throw new ClassNotFoundException();
				}
			}

		};

		public static void main(String args[]) throws Exception {
			MyClassLoader classLoader = new MyClassLoader("D:/test");
			Class clazz = classLoader.loadClass("com.luis.test.Test");
			Object obj = clazz.newInstance();
			Method helloMethod = clazz.getDeclaredMethod("hello", null);
			helloMethod.invoke(obj, null);
		}
	}
运行结果如下：

	我是由 class Main$MyClassLoader 加载进来的

本文參考了：
https://www.jianshu.com/p/5f79217f2e18
https://www.cnblogs.com/wxd0108/p/6681618.html
https://www.cnblogs.com/louistz/p/6295917.html
https://blog.csdn.net/zhangcanyan/article/details/78993959
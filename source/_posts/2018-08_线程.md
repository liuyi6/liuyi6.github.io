---
title: 理解java线程
date: 2018-08-19 19:54:19
tags: [Java进阶]
categories: Java进阶
---
使用多线程的目的是更好的利用cpu资源，大部分多线程代码都可以用单线程来实现，但也有无法用单线程实现的，如：生产者消费者模型
下面对一些常用的概念进行区分：
多线程：指的是这个程序（一个进程）运行时产生了不止一个线程。
并行与并发：
并行：多个cpu实例或者多台机器同时执行一段处理逻辑，真正的同时。
并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。
线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。若线程不安全则意味着线程调度顺序影响最终结果。如转账操作。
同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如在转账中加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。
# 线程的状态
线程共有五种状态，其状态转换如下图所示：
![](/images/2018-8-1/thread_attitude_five.png)
 - 新建态(New):新创建的线程对象。
 - 就绪态(Runnable):线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于“可运行线程池”中，变得可运行，只等待获取CPU的使用权。  即在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获得。
 - 运行态(Running):就绪状态的线程获取了CPU，执行程序代码。
 - 死亡态(Dead):线程执行完了或者因异常退出了run()方法，该线程结束生命周期。
 - 阻塞态(Blocked):阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。

阻塞的情况分三种：

 1. 等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒。
 2. 同步阻塞：运行的线程在获取对象的同步锁时(Synchronized)，同步锁被释放进入可运行状态(Runnable),若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。
 3. 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
注：在runnable状态的线程是处于被调度的线程，此时的调度顺序是不一定的。Thread类中的yield方法可以让一个running状态的线程转入runnable。

# 控制线程的基本方法
首先就要明确monitor的概念，Java中的每个对象都有一个监视器，来监测并发代码的重入。在非多线程编码时该监视器不发挥作用，反之如果在synchronized 范围内，监视器发挥作用。
## sleep()
sleep()方法属于Thread类，是一个静态方法，主要的作用是让当前线程停止执行，把cpu让给其他线程执行，但不会释放对象锁和监控的状态，到了指定时间后线程又会自动恢复运行状态
Java有两种sleep方法,一个只有一个毫秒参数,另一个有毫秒和纳秒两个参数
    sleep(long millis)
    sleep(long millis, int nanos)
注意：线程睡眠到期自动苏醒，并返回到可运行状态，不是运行状态。sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始执行。
## wait()与notify()
wait()属于Object类，与sleep()的区别是当前线程会释放锁，进入等待此对象的等待锁定池。若线程A调用Obj.wait(),线程A就会停止运行，而转为等待状态。至于等待时间，看其他线程是否调用Obj.notify()，成为多个线程之间进行通讯的有手段。
注意：无论是wait()还是notify()都需要首先获得目标的对象的一个监视器。wait/notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某对象的监视器）。这意味着wait之后，其他线程可以进入同步块执行。当某代码并不持有监视器的使用权时去wait或notify，会抛出java.lang.IllegalMonitorStateException。也包括在synchronized块中去调用另一个对象的wait/notify，因为不同对象的监视器不同，同样会抛出此异常。
"Synchronzied"是一种同步锁。作用是实现线程间同步，对同步的代码加锁，使得每一次，只能有一线程进入同步块，从而保证线程间的安全性。它修饰的对象有以下几种：
- 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的部分,进入同步代码前要获得给定对象的锁
- 修饰一个实例方法，进入同步代码前要获得当前实例的锁
- 修饰一个静态方法，进入同步代码前要获得当前类的锁


	public class Test {
		 final static Object object=new Object();
		 public static class Thread1 extends Thread{
			 @Override
			 public void run() {
				 synchronized (object) {
					 System.out.println("T1 开始");
					 try {
						 System.out.println("T1 等待");
						object.wait();
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					System.out.println("T1 结束");
				}                   
			 }   
		 }
		 public static class Thread2 extends Thread{
			 @Override
			 public void run() {
				 synchronized (object) {
					 System.out.println("T2 开始");
					 System.out.println("释放一个线程");
					 object.notify();
					 System.out.println("T2 结束");
				 }                   
			 }   
		 }
		 
		 public static void main(String[] args) throws InterruptedException {
			 Thread t1=new Thread1();
			 Thread t2=new Thread2();
			 t1.start();
			 t2.start();
			 t1.join();
			 t2.join();
		}
	}
运行结果：

	T1 开始
	T1 等待
	T2 开始
	释放一个线程
	T2 结束
	T1 结束
如下为生产者消费者模型：

	public class Test {
		private final int MAX_SIZE = 100;
		private LinkedList<Object> list = new LinkedList<Object>();

		/**
		 * 生产产品
		 * @param producer
		 */
		public void produce(String producer) {
			synchronized (list) {
				// 如果仓库已满
				while (list.size() == MAX_SIZE) {
					System.out.println("仓库已满，【"+producer+"】： 暂时不能执行生产任务!");
					try {
						// 由于条件不满足，生产阻塞
						list.wait();
					}
					catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
				// 生产产品            
				list.add(new Object());            
				System.out.println("【"+producer+"】：生产了一个产品\t【现仓储量为】:" + list.size());
				list.notifyAll();
			}
		}
		/**
		 * 消費产品
		 * @param consumer
		 */
		public void consume(String consumer) {
			synchronized (list) {
				//如果仓库存储量不足
				while (list.size()==0) {
					System.out.println("仓库已空，【"+consumer+"】： 暂时不能执行消费任务!");
					try {
						// 由于条件不满足，消费阻塞
						list.wait();
					}
					catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
				list.remove();
				System.out.println("【"+consumer+"】：消费了一个产品\t【现仓储量为】:" + list.size());
				list.notifyAll();
			}
		}

		public static void main(String[] args){
			Test test = new Test();
			for(int i=1;i<6;i++){
				int finalI = i;
				new Thread(new Runnable() {
					@Override
					public void run() {
						test.produce(String.format("生产者%d:", finalI));
					}
				}).start();
			}

			for(int i=1;i<4;i++){
				int finalI = i;
				new Thread(()-> test.consume(String.format("消费者%d:", finalI))).start();
			}
		}
	}
运行结果：

	仓库已空，【消费者2:】： 暂时不能执行消费任务!
	仓库已空，【消费者1:】： 暂时不能执行消费任务!
	【生产者4:】：生产了一个产品	【现仓储量为】:1
	【生产者1:】：生产了一个产品	【现仓储量为】:2
	【消费者3:】：消费了一个产品	【现仓储量为】:1
	【消费者1:】：消费了一个产品	【现仓储量为】:0
	【生产者2:】：生产了一个产品	【现仓储量为】:1
	【消费者2:】：消费了一个产品	【现仓储量为】:0
	【生产者5:】：生产了一个产品	【现仓储量为】:1
	【生产者3:】：生产了一个产品	【现仓储量为】:2
## join()
在某些情况下，子线程需要进行大量的耗时运算，主线程可能会在子线程执行结束之前结束，但是如果主线程又需要用到子线程的结果，换句话说，就是主线程需要在子线程执行之后再结束。这就需要用到join()方法

	public class Test {
		 public static int count;
			public static class AddThread implements Runnable{
				 @Override
				 public void run() {
					 for (int i = 0; i < 1000000000; i++) {
						 count++;
					 }   
				 }   
			}
			public static void main(String[] args) throws InterruptedException {
				AddThread addThread=new AddThread();
				Thread t1=new Thread(addThread);
				t1.start();
				t1.join();
				System.out.println(count);
			}
	}
## yield()
一个线程调用yield()意味着告诉虚拟机可以把自己的位置让给其他线程(这只是暗示，并不表绝对)。但要注意，让出cpu并不代表当前线程不执行了。当前线程让出cpu后，还会进行cpu资源的争夺，但是能不能再次分配到，就不一定了。使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。
## volatile
多线程的内存模型：main memory（主存）、working memory（线程栈），在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去(volatile关键词的作用：每次针对该变量的操作都激发一次load and save)。
针对多线程使用的变量如果不是volatile或者final修饰的，很有可能产生不可预知的结果（另一个线程修改了这个值，但是之后在某线程看到的是修改之前的值）。其实道理上讲同一实例的同一属性本身只有一个副本。但是多线程是会缓存值的，本质上，volatile就是不去缓存，直接取值。在线程安全的情况下加volatile会牺牲性能。
# 线程创建
Java多线程实现方式主要有四种：继承Thread类、实现Runnable接口、实现Callable接口通过FutureTask包装器来创建Thread线程、使用ExecutorService、Callable、Future实现有返回结果的多线程。
其中，其中前两种方式线程执行完后都没有返回值，后两种是带返回值的。
## 继承Thread类创建线程
Thread类本质上是实现了Runnable接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。这种方式实现多线程很简单，通过自己的类直接extend Thread，并复写run()方法，就可以启动新线程并执行自己定义的run()方法。

	public class MyThread extends Thread {  
		public void run() {  
			System.out.println("MyThread.run()");  
		}
		public static void main(String[] args) {
			MyThread myThread1 = new MyThread();  
			MyThread myThread2 = new MyThread();  
			myThread1.start();  
			myThread2.start(); 
		}
	}  
## 实现Runnable接口创建线程
如果自己的类已经extends另一个类，就无法直接extends Thread，此时，可以实现一个Runnable接口，代码如下：
	
	public class MyThread implements Runnable {  
		public void run() {  
			System.out.println("MyThread.run()");  
		}  
		public static void main(String[] args) {
			MyThread myThread1 = new MyThread();  
			MyThread myThread2 = new MyThread();  
			myThread1.start();  
			myThread2.start(); 
		}
	}
## 实现Callable接口,通过FutureTask包装器创建线程

    /**
     * 实现Callable接口创建线程，相较于实现Runnable接口的方式，方法可以有返回值，并且可以抛出异常
     * 执行Callable方式，需要FutureTask实现类的支持，用于接收运算结果
     */
    public class Test {
        public static void main(String[] args) {
            ThreadDemo td = new ThreadDemo();
             // 执行Callable方式，需要FutureTask实现类的支持，用于接收运算结果
             FutureTask<Integer> result = new FutureTask<>(td);
             new Thread(result).start();

             // 接收线程运算后的结果
             Integer sum;
             try {
                 //等所有线程执行完，获取值，因此FutureTask 可用于 闭锁
                 sum = result.get();
                 System.out.println("-----------------------------");
                 System.out.println(sum);
             } catch (Exception e) {
                 e.printStackTrace();
             }
        }
    }

    class ThreadDemo implements Callable<Integer> {
        @Override
        public Integer call() throws Exception {
            int sum = 0;
            for (int i = 0; i <= 100000; i++) {
                sum += i;
            }
            return sum;
        }
    }
## 使用线程池创建返回结果的线程
使用ExecutorService、Callable、Future实现有返回结果的线程,ExecutorService、Callable、Future三个接口实际上都是属于Executor框架。返回结果的线程是在JDK1.5中引入的新特征，有了这种特征可以很方便的得到返回值了,可返回值的任务必须实现Callable接口。类似的，无返回值的任务必须实现Runnable接口。
执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object了。
注意：get方法是阻塞的，即：线程无返回结果，get方法会一直等待。再结合线程池接口ExecutorService就可以实现传说中有返回结果的多线程了。

	public class Demo {
		public static void main(String[] args) throws Exception {  
		   System.out.println("----程序开始运行----");  
		   Date date1 = new Date();  

		   int taskSize = 5;  
		   // 创建一个线程池  
		   ExecutorService pool = Executors.newFixedThreadPool(taskSize);  
		   // 创建多个有返回值的任务  
		   List<Future> list = new ArrayList<Future>();  
		   for (int i = 0; i < taskSize; i++) {  
				Callable c = new MyCallable(i + " ");  
				// 执行任务并获取Future对象  
				Future f = pool.submit(c);  
				// System.out.println(">>>" + f.get().toString());  
				list.add(f);  
		   }  
		   // 关闭线程池  
		   pool.shutdown();  
		   // 获取所有并发任务的运行结果  
		   for (Future f : list) {  
				// 从Future对象上获取任务的返回值，并输出到控制台  
				System.out.println(">>>" + f.get().toString());  
		   }  
		   Date date2 = new Date();  
		   System.out.println("----程序结束运行----，程序运行时间【"+ (date2.getTime() - date1.getTime()) + "毫秒】");  
		}  
	}  

	class MyCallable implements Callable<Object> {  
		private String taskNum;  
		MyCallable(String taskNum) {  
		   this.taskNum = taskNum;  
		}  

		public Object call() throws Exception {  
		   System.out.println(">>>" + taskNum + "任务启动");  
		   Date dateTmp1 = new Date();  
		   Thread.sleep(1000);  
		   Date dateTmp2 = new Date();  
		   long time = dateTmp2.getTime() - dateTmp1.getTime();  
		   System.out.println(">>>" + taskNum + "任务终止");  
		   return taskNum + "任务返回运行结果,当前任务时间【" + time + "毫秒】";  
		}  
	}  
运行结果：

	----程序开始运行----
	>>>0 任务启动
	>>>2 任务启动
	>>>4 任务启动
	>>>1 任务启动
	>>>3 任务启动
	>>>2 任务终止
	>>>4 任务终止
	>>>0 任务终止
	>>>0 任务返回运行结果,当前任务时间【1000毫秒】
	>>>1 任务终止
	>>>3 任务终止
	>>>1 任务返回运行结果,当前任务时间【1000毫秒】
	>>>2 任务返回运行结果,当前任务时间【1000毫秒】
	>>>3 任务返回运行结果,当前任务时间【1000毫秒】
	>>>4 任务返回运行结果,当前任务时间【1000毫秒】
	----程序结束运行----，程序运行时间【1074毫秒】
程序说明：
上述代码中Executors类，提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。
public static ExecutorService newFixedThreadPool(int nThreads) 
创建固定数目线程的线程池。
public static ExecutorService newCachedThreadPool() 
创建一个可缓存的线程池，调用execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。
public static ExecutorService newSingleThreadExecutor() 
创建一个单线程化的Executor。
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 
创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。
ExecutoreService提供了submit()方法，传递一个Callable，或Runnable，返回Future。如果Executor后台线程池还没有完成Callable的计算，这调用返回Future对象的get()方法，会阻塞直到计算完成。

本文参考了：
https://www.cnblogs.com/wxd0108/p/5479442.html
https://www.cnblogs.com/Ming8006/p/7243858.html
https://www.cnblogs.com/felixzh/p/6036074.html
https://www.cnblogs.com/ccfdod/p/6396012.html
http://www.cnblogs.com/jijijiefang/articles/7222955.html
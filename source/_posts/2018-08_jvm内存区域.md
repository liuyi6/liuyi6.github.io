---
title: 深入理解jvm之Java内存区域
date: 2018-07-25 18:26:19
tags: [jvm,内存区域]
categories: jvm
---


Java虚拟机运行时数据区分为以下几个部分：
方法区、虚拟机栈、本地方法栈、堆、程序计数器。如下图所示：
![运行时数据区域](/images/2018-7-31/jvm_data.png)
程序计数器
---
程序计数器可看作当前线程所执行的字节码行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。Java虚拟机的多线程是通过线程轮流切换以分配处理执行时间的方式进行的，因而为了确保线程切换后能够恢复到正确的执行位置，每条线程都有一个独立的程序计数器，各个线程计数器独立存储，互不影响，这类内存区域称为“线程私有”内存。当线程执行Java方法时，计数器记录的时正在执行虚拟机字节码指令的地址；如果执行Native方法，则计数器值为空(Undefine)。
**程序计数器时唯一一个在Java虚拟机规范中没有任何规定OutOfMemoryError情况的内存区域。**
Java虚拟机栈
---
Java虚拟机栈也是线程私有的，生命周期与线程相同。Java虚拟机栈是描述Java方法执行的内存模型：每个方法执行时都会创建一个栈帧(方法运行期间的基础数据结构)，方法的执行过程对应着相应的栈帧在虚拟机中从入栈到出栈的过程。我们平时提到的栈就是虚拟机栈，也称为局部变量表部分。
局部变量表存放了编译期间的各种基本数据类型、对象引用和returAdress类型。其中，double和long占两个局部变量空间(Slot)，其余数据类型占据一个。局部变量表所需内存是在编译期间完成分配的，当进入一个方法时，方法在帧中分配的局部变量空间大小是完全确定的，在方法运行期间局部变量表的大小不变。
Java虚拟机栈规定了两种异常状况：

1. 线程请求栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常。
2. 虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时抛出OutOfMemoryError异常。

本地方法栈
---
本地方法栈为虚拟机使用的Native方法服务，本地方法栈可根据虚拟机的具体要求自由实现。由的虚拟机(如Sun HotSpot虚拟机)直接将本地方法栈和虚拟机栈赫尔为一。
本地方法栈出现的异常为StackOverflowError和OutOfMemoryError异常。
Java堆
---
Java堆(Java Heap)是Java虚拟机内存中最大的一块。堆被所有线程共享，在虚拟机启动时创建。堆的唯一目的就是存放对象实例。一般来说，几乎所有的对象实例都在堆上分配内存。
Java堆是垃圾收集器管理的主要区域，因此又称为“GC堆”。(为什么莫名想到垃圾堆？)从内存回收角度由于收集器采用分代收集算法，故将Java堆细分为新生代，老生代；从内存分配角度将线程共享的堆划分为多个线程私有分配缓冲区。
Java堆处于物理不连接的内存空间中，只要逻辑上连续即可。如果堆中没有内存完成实例分配，且堆无法再扩展时抛出OutOfMemoryError异常。
方法区
---
方法区也是线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时候编译器编译后的代码等数据。Java虚拟机规范将方法区描述为堆的一个逻辑部分，但为与java堆进行区分，称它为Non-Heap(非堆)。由于HotSpot虚拟机用永久代来实现方法区，因而部分人习惯将方法区称为“永久代”。垃圾回收在方法区是较少出现的，这个区域内存回收主要目标是对常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。
运行时常量池
---
运行时常量池是方法区的一部分，常量池是包含在Class文件中的一项信息，用于存放编译期生成的各种自面量和符号引用，这部分信息将在类加载后存放到方法区的运行时常量池中。一般来说，除了保存Class文件中的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。
运行时常量池与Class文件常量池相比具有动态性，并非时只有预置在Class文件中的常量池内容才能进入运行时常量池，运行期间也可以将新的常量放入池中，如String的intern()方法。当常量池无法再申请到内存时抛出OutOfMemoryError异常。
直接内存
---
直接内存并不是虚拟机运行时数据区的一部分，但这部分内存被频繁的使用，也会OutOfMemoryError异常的出现。
JDK1.4加入Input/Output类,引入基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，再通过Java堆中的DirectByteBuffer对象引用这块内存，以提高性能。它一般受到本机总内存与处理器寻址空间的限制，从而导致OutOfMemoryError异常。

本文主要参考《深入理解Java虚拟机——JVM高级特性与最佳实践》一书
另参考文章:
https://blog.csdn.net/u011116672/article/details/50994109
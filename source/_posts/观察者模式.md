---
title: 设计模式之观察者模式
date: 2018-08-10 22:26:19
tags: [设计模式]
categories: 设计模式
---
观察者模式定义
---
观察者模式定义了一系列对象之间的一对多关系，当一个对象改变状态，其他依赖者都会收到通知。又称为发布-订阅模式。
观察者模式结构
---
![](/images/2018-8-1/design_partten_observe_class.gif)
其中的角色有：
Subject为主题接口，对象使用此接口注册为观察者，或把自己从观察者中删除。
Observer为所有观察者必须实现的接口，其中只有updata()方法，当主题状态改变时调用。
ConcreteSubject类为实现主题接口的具体类，它包括注册方法Attach()、撤销方法Detach()、以及更新观察者状态的Notify()。除此外，具体主题还可能有设置与获取状态的方法。
ConcreteObserver类为具体的观察者它必须注册具体的主题，以便于接受更新消息。
观察者模式实现
---
**问题描述**
目前有一个气象站，由WeatherData类进行天气追踪，有两种显示天气数据的布告板，可对数据进行实时更新。此外，需提供布告板API，供其它开发人员写自己的布告板。
**问题分析与设计**
下面就采用观察者模式对问题进行解决。下图为项目结构图：
![](/images/2018-8-1/desingn_pattern_observer_project_structure.png)
经分析，气象站设计的类图如下所示：
![](/images/2018-8-1/design_pattern_observer_project_class.png)
注：问题中原有三个布告板，因而类图中有三个观察者，这里博主偷了个懒，只实现来两个，见谅
**代码实现**
首先建立主题接口：

    public interface Subject {
        /**
         * 注册观察者
         * @param o
         */
        public void registerObserver(Observer o);
        /**
         * 移除观察者
         * @param o
         */
        public void removeObserver(Observer o);
        /**
         * 当状态改变时，调用此方法通知所有观察者
         */
        public void notifyObserver();
    }
建立观察者接口：

    public  interface Observer {
        /**
         * 当气象值改变时，将状态参数传递给观察者
         * @param temp
         * @param humidity
         * @param pressure
         */
        public void update(float temp,float humidity,float pressure);
    }
建立布告板信息推送接口

    public interface DisplayElement {
        /**
         * 当布告板显示时调用此方法
         */
        public void display();
    }
WeaterData实现主题接口：

    public class WeatherData implements Subject {

        private ArrayList<Observer> observers;
        private float temperature;
        private float humidity;
        private float pressure;

        public WeatherData() {
            observers = new ArrayList<Observer>();
        }
        /**
         * 当注册观察者，将其加入观察者列表
         */
        @Override
        public void registerObserver(Observer o) {
            observers.add(o);
        }
        /**
         * 观察者取消注册，将其从注册列表中移除
         */
        @Override
        public void removeObserver(Observer o) {
            int i = observers.indexOf(o);
            if (i >= 0) {
                observers.remove(i);
            }
        }
        /**
         * 通知每一个观察者
         */
        @Override
        public void notifyObserver() {

            for (Observer observer : observers) {
                observer.update(temperature, humidity, pressure);
            }
        }
        /**
         * 当气象数值更新时，通知观察者
         */
        public void measurementsChange() {
            notifyObserver();
        }
        /**
         * 设置气象站数据
         * @param temperature
         * @param humidity
         * @param pressure
         */
        public void setMeassurement(float temperature,float humidity,float pressure) {
            this.pressure = pressure;
            this.temperature = temperature;
            this.humidity = humidity;
            measurementsChange();
        }
    }
建立环境状况布告板：

    public class CurrentConditionsDisplay implements Observer, DisplayElement {
        private float temperature;
        private float humidity;
        private Subject weatherData;

        public CurrentConditionsDisplay(Subject weatherData) {
            this.weatherData = weatherData;
            weatherData.registerObserver(this);
        }

        @Override
        public void update(float temp, float humidity, float pressure) {
            this.temperature = temp;
            this.humidity = humidity;
            display();
        }

        @Override
        public void display() {
            System.out.println("环境状况：温度为"+temperature+"，湿度为："+humidity);
        }
    }
建立天气预报布告板：

    public class FoecastDisplay implements DisplayElement, Observer {
        private float preasure;
        private Subject weatherData;

        public FoecastDisplay(Subject weatherData) {
            this.weatherData = weatherData;
            weatherData.registerObserver(this);
        }
        @Override
        public void update(float temp, float humidity, float pressure) {
            this.preasure = pressure;
            display();
        }

        @Override
        public void display() {
            System.out.println("天气预报：气压为" + preasure);
        }
    }
**代码测试**
至此，我们的气象站即将完成，现在进行测试：

    public class Test {
        public static void main(String[] args) {
            WeatherData weatherData = new WeatherData();

            CurrentConditionsDisplay conditionsDisplay = new CurrentConditionsDisplay(weatherData);

            FoecastDisplay foecastDisplay = new FoecastDisplay(weatherData);

            weatherData.setMeassurement(80, 65, 30.4f);
			weatherData.setMeassurement(82, 70, 29.4f);
        }
    }
当设置当前的天气数据时，观察者得到数据，结果如下：

    环境状况：温度为80.0，湿度为：65.0
    天气预报：气压为30.4
    环境状况：温度为82.0，湿度为：70.0
    天气预报：气压为30.4
观察者们都获得了消息推送，气象站建造成功!
观察者模式总结
---
**优缺点**
优点：
1. 观察者和被观察者是抽象耦合的。
2. 建立一套触发机制。

缺点：
1. 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
2. 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3. 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

**使用场景**

- 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
- 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
- 一个对象必须通知其他对象，而并不知道这些对象是谁。
- 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。

**注意事项**
1. JAVA 中已经有了对观察者模式的支持类。 
2. 避免循环引用。 
3. 如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。

本文主要参考自《Head First设计模式》一书。
另参考：
http://www.runoob.com/design-pattern/observer-pattern.html
https://blog.csdn.net/itachi85/article/details/50773358